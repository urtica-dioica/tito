a8d4d4daa36c333d0b13297e0e57dcf8
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Mock the models
jest.mock('../../../src/models/leave/Leave');
jest.mock('../../../src/models/leave/LeaveBalance');
jest.mock('../../../src/models/hr/Employee');
const leaveService_1 = require("../../../src/services/leave/leaveService");
const Leave_1 = require("../../../src/models/leave/Leave");
const LeaveBalance_1 = require("../../../src/models/leave/LeaveBalance");
const Employee_1 = require("../../../src/models/hr/Employee");
const mockLeaveModel = Leave_1.leaveModel;
const mockLeaveBalanceModel = LeaveBalance_1.leaveBalanceModel;
const mockEmployeeModel = Employee_1.employeeModel;
describe('LeaveService', () => {
    let leaveService;
    // Shared mock data
    const validLeaveData = {
        employeeId: 'emp-123',
        leaveType: 'vacation',
        startDate: new Date('2025-12-15'),
        endDate: new Date('2025-12-17'),
        reason: 'Family vacation'
    };
    const mockEmployee = {
        id: 'emp-123',
        user_id: 'user-123',
        employee_id: 'EMP001',
        position: 'Software Developer',
        department_id: 'dept-123',
        employment_type: 'regular',
        hire_date: new Date('2023-01-01'),
        base_salary: 50000,
        status: 'active',
        created_at: new Date(),
        updated_at: new Date()
    };
    const mockLeave = {
        id: 'leave-123',
        employeeId: 'emp-123',
        leaveType: 'vacation',
        startDate: new Date('2025-12-15'),
        endDate: new Date('2025-12-17'),
        totalDays: 3,
        reason: 'Family vacation',
        status: 'pending',
        approvedBy: null,
        createdAt: new Date(),
        updatedAt: new Date()
    };
    beforeEach(() => {
        leaveService = new leaveService_1.LeaveService();
        jest.clearAllMocks();
    });
    describe('createLeaveRequest', () => {
        it('should create a leave request successfully', async () => {
            // Arrange
            mockEmployeeModel.findById.mockResolvedValue(mockEmployee);
            mockLeaveModel.createLeave.mockResolvedValue(mockLeave);
            // Mock the specific method called by createLeaveRequest
            mockLeaveBalanceModel.findByEmployeeLeaveTypeAndYear.mockResolvedValue({
                id: 'lb-1',
                employeeId: 'emp-123',
                leaveType: 'vacation',
                balance: 15,
                year: 2025,
                updatedAt: new Date()
            });
            // Mock checkOverlappingLeaves to return no overlaps
            mockLeaveModel.checkOverlappingLeaves.mockResolvedValue([]);
            mockLeaveModel.listLeaves.mockResolvedValue({ leaves: [], total: 0, page: 1, limit: 10, totalPages: 1 });
            // Act
            const result = await leaveService.createLeaveRequest(validLeaveData);
            // Assert
            expect(mockEmployeeModel.findById).toHaveBeenCalledWith('emp-123');
            expect(mockLeaveModel.createLeave).toHaveBeenCalledWith({
                employeeId: 'emp-123',
                leaveType: 'vacation',
                startDate: new Date('2025-12-15'),
                endDate: new Date('2025-12-17'),
                reason: 'Family vacation',
                totalDays: 3
            });
            expect(result).toEqual(mockLeave);
        });
        it('should throw error if employee not found', async () => {
            // Arrange
            mockEmployeeModel.findById.mockResolvedValue(null);
            // Act & Assert
            await expect(leaveService.createLeaveRequest(validLeaveData))
                .rejects.toThrow('Employee not found');
        });
        it('should throw error if employee is not active', async () => {
            // Arrange
            const inactiveEmployee = { ...mockEmployee, status: 'inactive' };
            mockEmployeeModel.findById.mockResolvedValue(inactiveEmployee);
            // Act & Assert
            await expect(leaveService.createLeaveRequest(validLeaveData))
                .rejects.toThrow('Employee is not active');
        });
        it('should throw error if end date is before start date', async () => {
            // Arrange
            const invalidData = {
                ...validLeaveData,
                startDate: new Date('2025-12-17'),
                endDate: new Date('2025-12-15')
            };
            mockEmployeeModel.findById.mockResolvedValue(mockEmployee);
            // Act & Assert
            await expect(leaveService.createLeaveRequest(invalidData))
                .rejects.toThrow('Start date must be before end date');
        });
        it('should throw error if leave request is for past dates', async () => {
            // Arrange
            const pastDate = new Date();
            pastDate.setDate(pastDate.getDate() - 1);
            const pastEndDate = new Date();
            pastEndDate.setDate(pastEndDate.getDate() - 1);
            pastEndDate.setDate(pastEndDate.getDate() + 2); // Make end date after start date
            const invalidData = {
                ...validLeaveData,
                startDate: pastDate,
                endDate: pastEndDate
            };
            mockEmployeeModel.findById.mockResolvedValue(mockEmployee);
            // Act & Assert
            await expect(leaveService.createLeaveRequest(invalidData))
                .rejects.toThrow('Cannot request leave for past dates');
        });
    });
    describe('getLeaveRequest', () => {
        const mockLeaveWithDetails = {
            id: 'leave-123',
            employeeId: 'emp-123',
            leaveType: 'vacation',
            startDate: new Date('2025-12-15'),
            endDate: new Date('2025-12-17'),
            totalDays: 3,
            reason: 'Family vacation',
            status: 'pending',
            approvedBy: null,
            createdAt: new Date(),
            updatedAt: new Date(),
            employeeCode: 'EMP001',
            employeeName: 'John Doe',
            departmentName: 'Engineering',
            approverName: null
        };
        it('should return leave request with details', async () => {
            // Arrange
            mockLeaveModel.findByIdWithDetails.mockResolvedValue(mockLeaveWithDetails);
            // Act
            const result = await leaveService.getLeaveRequest('leave-123');
            // Assert
            expect(mockLeaveModel.findByIdWithDetails).toHaveBeenCalledWith('leave-123');
            expect(result).toEqual(mockLeaveWithDetails);
        });
        it('should return null if leave request not found', async () => {
            // Arrange
            mockLeaveModel.findByIdWithDetails.mockResolvedValue(null);
            // Act
            const result = await leaveService.getLeaveRequest('nonexistent');
            // Assert
            expect(result).toBeNull();
        });
    });
    describe('approveLeaveRequest', () => {
        const mockLeave = {
            id: 'leave-123',
            employeeId: 'emp-123',
            leaveType: 'vacation',
            startDate: new Date('2025-12-15'),
            endDate: new Date('2025-12-17'),
            totalDays: 3,
            reason: 'Family vacation',
            status: 'pending',
            approvedBy: null,
            createdAt: new Date(),
            updatedAt: new Date()
        };
        const approveData = {
            leaveId: 'leave-123',
            approverId: 'approver-123',
            approved: true,
            comments: 'Approved for family vacation'
        };
        it('should approve leave request successfully', async () => {
            // Arrange
            mockLeaveModel.findById.mockResolvedValue(mockLeave);
            mockLeaveModel.updateLeave.mockResolvedValue({
                ...mockLeave,
                status: 'approved',
                approvedBy: 'approver-123',
            });
            // Mock the specific method called by approveLeaveRequest
            mockLeaveBalanceModel.useLeaveDays.mockResolvedValue({
                id: 'lb-1',
                employeeId: 'emp-123',
                leaveType: 'vacation',
                balance: 12, // 15 - 3 days
                year: 2025,
                updatedAt: new Date()
            });
            // Act
            const result = await leaveService.approveLeaveRequest(approveData);
            // Assert
            expect(mockLeaveModel.findById).toHaveBeenCalledWith('leave-123');
            expect(mockLeaveModel.updateLeave).toHaveBeenCalledWith('leave-123', {
                status: 'approved',
                approvedBy: 'approver-123',
            });
            expect(result.status).toBe('approved');
        });
        it('should reject leave request successfully', async () => {
            // Arrange
            const rejectData = { ...approveData, approved: false };
            mockLeaveModel.findById.mockResolvedValue(mockLeave);
            mockLeaveModel.updateLeave.mockResolvedValue({
                ...mockLeave,
                status: 'rejected',
                approvedBy: 'approver-123',
            });
            // Act
            const result = await leaveService.approveLeaveRequest(rejectData);
            // Assert
            expect(result.status).toBe('rejected');
        });
        it('should throw error if leave request not found', async () => {
            // Arrange
            mockLeaveModel.findById.mockResolvedValue(null);
            // Act & Assert
            await expect(leaveService.approveLeaveRequest(approveData))
                .rejects.toThrow('Leave request not found');
        });
        it('should throw error if leave request is already processed', async () => {
            // Arrange
            const processedLeave = { ...mockLeave, status: 'approved' };
            mockLeaveModel.findById.mockResolvedValue(processedLeave);
            // Act & Assert
            await expect(leaveService.approveLeaveRequest(approveData))
                .rejects.toThrow('Request has already been processed');
        });
    });
    describe('getEmployeeLeaveBalance', () => {
        const mockLeaveBalances = [
            {
                id: 'lb-1',
                employeeId: 'emp-123',
                leaveType: 'vacation',
                balance: 15,
                year: 2025,
                updatedAt: new Date(),
                employeeCode: 'EMP001',
                employeeName: 'John Doe',
                departmentName: 'Engineering'
            },
            {
                id: 'lb-2',
                employeeId: 'emp-123',
                leaveType: 'sick',
                balance: 10,
                year: 2025,
                updatedAt: new Date(),
                employeeCode: 'EMP001',
                employeeName: 'John Doe',
                departmentName: 'Engineering'
            }
        ];
        it('should return leave balance summary for employee', async () => {
            // Arrange
            mockLeaveBalanceModel.getEmployeeLeaveBalances.mockResolvedValue(mockLeaveBalances);
            // Act
            const result = await leaveService.getEmployeeLeaveBalance('emp-123', 2025);
            // Assert
            expect(mockLeaveBalanceModel.getEmployeeLeaveBalances).toHaveBeenCalledWith('emp-123', 2025);
            expect(result).toEqual({
                vacation: { total: 15, used: 0, available: 15 },
                sick: { total: 10, used: 0, available: 10 },
                maternity: { total: 0, used: 0, available: 0 },
                other: { total: 0, used: 0, available: 0 }
            });
        });
        it('should use current year if year not provided', async () => {
            // Arrange
            const currentYear = new Date().getFullYear();
            mockLeaveBalanceModel.getEmployeeLeaveBalances.mockResolvedValue([]);
            // Act
            await leaveService.getEmployeeLeaveBalance('emp-123');
            // Assert
            expect(mockLeaveBalanceModel.getEmployeeLeaveBalances).toHaveBeenCalledWith('emp-123', currentYear);
        });
        it('should return zero balances if no leave balances found', async () => {
            // Arrange
            mockLeaveBalanceModel.getEmployeeLeaveBalances.mockResolvedValue([]);
            // Act
            const result = await leaveService.getEmployeeLeaveBalance('emp-123', 2024);
            // Assert
            expect(result).toEqual({
                vacation: { total: 0, used: 0, available: 0 },
                sick: { total: 0, used: 0, available: 0 },
                maternity: { total: 0, used: 0, available: 0 },
                other: { total: 0, used: 0, available: 0 }
            });
        });
    });
    describe('validateLeaveRequest', () => {
        const validLeaveData = {
            employeeId: 'emp-123',
            leaveType: 'vacation',
            startDate: new Date('2025-12-15'),
            endDate: new Date('2025-12-17'),
            reason: 'Family vacation'
        };
        it('should validate leave request successfully', async () => {
            // Arrange
            // Mock the specific method called by validateLeaveRequest
            mockLeaveBalanceModel.findByEmployeeLeaveTypeAndYear.mockResolvedValue({
                id: 'lb-1',
                employeeId: 'emp-123',
                leaveType: 'vacation',
                balance: 15,
                year: 2025,
                updatedAt: new Date()
            });
            mockLeaveModel.checkOverlappingLeaves.mockResolvedValue([]);
            // Act
            const result = await leaveService.validateLeaveRequest(validLeaveData);
            // Assert
            expect(result.isValid).toBe(true);
            expect(result.errors).toHaveLength(0);
        });
        it('should return validation errors for insufficient leave balance', async () => {
            // Arrange
            const insufficientBalanceData = {
                ...validLeaveData,
                startDate: new Date('2025-12-15'),
                endDate: new Date('2025-12-31') // 16 days
            };
            // Mock employee lookup
            mockEmployeeModel.findById.mockResolvedValue(mockEmployee);
            // Mock the specific method called by validateLeaveRequest
            mockLeaveBalanceModel.findByEmployeeLeaveTypeAndYear.mockResolvedValue({
                id: 'lb-1',
                employeeId: 'emp-123',
                leaveType: 'vacation',
                balance: 15, // Less than the 16 days requested
                year: 2025,
                updatedAt: new Date()
            });
            // Mock checkOverlappingLeaves to return no overlaps
            mockLeaveModel.checkOverlappingLeaves.mockResolvedValue([]);
            // Act
            const result = await leaveService.validateLeaveRequest(insufficientBalanceData);
            // Assert
            expect(result.isValid).toBe(false);
            expect(result.errors).toContain('Insufficient leave balance. Available: 15 days, Requested: 16 days');
        });
        it('should return validation errors for overlapping requests', async () => {
            // Arrange
            const mockOverlappingRequests = [
                {
                    id: 'leave-456',
                    employeeId: 'emp-123',
                    leaveType: 'sick',
                    startDate: new Date('2024-01-16'),
                    endDate: new Date('2024-01-18'),
                    totalDays: 3,
                    reason: null,
                    status: 'pending',
                    approvedBy: null,
                    createdAt: new Date(),
                    updatedAt: new Date()
                }
            ];
            mockLeaveBalanceModel.getEmployeeLeaveBalances.mockResolvedValue([]);
            mockLeaveModel.checkOverlappingLeaves.mockResolvedValue(mockOverlappingRequests);
            // Act
            const result = await leaveService.validateLeaveRequest(validLeaveData);
            // Assert
            expect(result.isValid).toBe(false);
            expect(result.errors).toContain('Leave request overlaps with existing approved leave');
        });
    });
    describe('getEmployeeLeaveRequests', () => {
        const mockLeaveRequests = [
            {
                id: 'leave-123',
                employeeId: 'emp-123',
                leaveType: 'vacation',
                startDate: new Date('2025-12-15'),
                endDate: new Date('2025-12-17'),
                totalDays: 3,
                reason: 'Family vacation',
                status: 'approved',
                approvedBy: 'approver-123',
                createdAt: new Date(),
                updatedAt: new Date(),
                employeeCode: 'EMP001',
                employeeName: 'John Doe',
                departmentName: 'Engineering',
                approverName: 'Jane Smith'
            }
        ];
        it('should return employee leave requests', async () => {
            // Arrange
            mockLeaveModel.listLeaves.mockResolvedValue({ leaves: mockLeaveRequests, total: 1, page: 1, limit: 10, totalPages: 1 });
            // Act
            const result = await leaveService.getEmployeeLeaveRequests('emp-123');
            // Assert
            expect(mockLeaveModel.listLeaves).toHaveBeenCalledWith({
                employeeId: 'emp-123',
                startDate: undefined,
                endDate: undefined,
                page: 1,
                limit: 20,
                sortBy: 'created_at',
                sortOrder: 'desc'
            });
            expect(result).toEqual({
                leaves: mockLeaveRequests,
                total: 1,
                page: 1,
                limit: 10,
                totalPages: 1
            });
        });
        it('should use current year if year not provided', async () => {
            // Arrange
            mockLeaveModel.listLeaves.mockResolvedValue({ leaves: [], total: 0, page: 1, limit: 10, totalPages: 1 });
            // Act
            await leaveService.getEmployeeLeaveRequests('emp-123');
            // Assert
            expect(mockLeaveModel.listLeaves).toHaveBeenCalledWith({
                employeeId: 'emp-123',
                startDate: undefined,
                endDate: undefined,
                page: 1,
                limit: 20,
                sortBy: 'created_at',
                sortOrder: 'desc'
            });
        });
    });
    describe('deleteLeaveRequest', () => {
        it('should delete leave request successfully', async () => {
            // Arrange
            mockLeaveModel.findById.mockResolvedValue(mockLeave);
            mockLeaveModel.deleteLeave.mockResolvedValue(true);
            // Act
            const result = await leaveService.deleteLeaveRequest('leave-123');
            // Assert
            expect(mockLeaveModel.findById).toHaveBeenCalledWith('leave-123');
            expect(mockLeaveModel.deleteLeave).toHaveBeenCalledWith('leave-123');
            expect(result).toBe(true);
        });
        it('should throw error if leave request not found', async () => {
            // Arrange
            mockLeaveModel.findById.mockResolvedValue(null);
            // Act & Assert
            await expect(leaveService.deleteLeaveRequest('nonexistent'))
                .rejects.toThrow('Leave request not found');
            expect(mockLeaveModel.findById).toHaveBeenCalledWith('nonexistent');
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUva2ltL3RpdG8vc2VydmVyL3Rlc3RzL3VuaXQvc2VydmljZXMvbGVhdmVTZXJ2aWNlLnRlc3QudHMiLCJtYXBwaW5ncyI6Ijs7QUFLQSxrQkFBa0I7QUFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDO0FBQzdDLElBQUksQ0FBQyxJQUFJLENBQUMsd0NBQXdDLENBQUMsQ0FBQztBQUNwRCxJQUFJLENBQUMsSUFBSSxDQUFDLGlDQUFpQyxDQUFDLENBQUM7QUFSN0MsMkVBQWtIO0FBQ2xILDJEQUFzRjtBQUN0Rix5RUFBb0c7QUFDcEcsOERBQWdFO0FBT2hFLE1BQU0sY0FBYyxHQUFHLGtCQUE0QyxDQUFDO0FBQ3BFLE1BQU0scUJBQXFCLEdBQUcsZ0NBQTBELENBQUM7QUFDekYsTUFBTSxpQkFBaUIsR0FBRyx3QkFBa0QsQ0FBQztBQUU3RSxRQUFRLENBQUMsY0FBYyxFQUFFLEdBQUcsRUFBRTtJQUM1QixJQUFJLFlBQTBCLENBQUM7SUFFL0IsbUJBQW1CO0lBQ25CLE1BQU0sY0FBYyxHQUEyQjtRQUM3QyxVQUFVLEVBQUUsU0FBUztRQUNyQixTQUFTLEVBQUUsVUFBVTtRQUNyQixTQUFTLEVBQUUsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDO1FBQ2pDLE9BQU8sRUFBRSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUM7UUFDL0IsTUFBTSxFQUFFLGlCQUFpQjtLQUMxQixDQUFDO0lBRUYsTUFBTSxZQUFZLEdBQUc7UUFDbkIsRUFBRSxFQUFFLFNBQVM7UUFDYixPQUFPLEVBQUUsVUFBVTtRQUNuQixXQUFXLEVBQUUsUUFBUTtRQUNyQixRQUFRLEVBQUUsb0JBQW9CO1FBQzlCLGFBQWEsRUFBRSxVQUFVO1FBQ3pCLGVBQWUsRUFBRSxTQUFrQjtRQUNuQyxTQUFTLEVBQUUsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDO1FBQ2pDLFdBQVcsRUFBRSxLQUFLO1FBQ2xCLE1BQU0sRUFBRSxRQUFpQjtRQUN6QixVQUFVLEVBQUUsSUFBSSxJQUFJLEVBQUU7UUFD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QztBQUNMLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9ob21lL2tpbS90aXRvL3NlcnZlci90ZXN0cy91bml0L3NlcnZpY2VzL2xlYXZlU2VydmljZS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExlYXZlU2VydmljZSwgQ3JlYXRlTGVhdmVSZXF1ZXN0RGF0YSwgQXBwcm92ZUxlYXZlRGF0YSB9IGZyb20gJy4uLy4uLy4uL3NyYy9zZXJ2aWNlcy9sZWF2ZS9sZWF2ZVNlcnZpY2UnO1xuaW1wb3J0IHsgbGVhdmVNb2RlbCwgTGVhdmUsIExlYXZlV2l0aERldGFpbHMgfSBmcm9tICcuLi8uLi8uLi9zcmMvbW9kZWxzL2xlYXZlL0xlYXZlJztcbmltcG9ydCB7IGxlYXZlQmFsYW5jZU1vZGVsLCBMZWF2ZUJhbGFuY2VXaXRoRGV0YWlscyB9IGZyb20gJy4uLy4uLy4uL3NyYy9tb2RlbHMvbGVhdmUvTGVhdmVCYWxhbmNlJztcbmltcG9ydCB7IGVtcGxveWVlTW9kZWwgfSBmcm9tICcuLi8uLi8uLi9zcmMvbW9kZWxzL2hyL0VtcGxveWVlJztcblxuLy8gTW9jayB0aGUgbW9kZWxzXG5qZXN0Lm1vY2soJy4uLy4uLy4uL3NyYy9tb2RlbHMvbGVhdmUvTGVhdmUnKTtcbmplc3QubW9jaygnLi4vLi4vLi4vc3JjL21vZGVscy9sZWF2ZS9MZWF2ZUJhbGFuY2UnKTtcbmplc3QubW9jaygnLi4vLi4vLi4vc3JjL21vZGVscy9oci9FbXBsb3llZScpO1xuXG5jb25zdCBtb2NrTGVhdmVNb2RlbCA9IGxlYXZlTW9kZWwgYXMgamVzdC5Nb2NrZWQ8dHlwZW9mIGxlYXZlTW9kZWw+O1xuY29uc3QgbW9ja0xlYXZlQmFsYW5jZU1vZGVsID0gbGVhdmVCYWxhbmNlTW9kZWwgYXMgamVzdC5Nb2NrZWQ8dHlwZW9mIGxlYXZlQmFsYW5jZU1vZGVsPjtcbmNvbnN0IG1vY2tFbXBsb3llZU1vZGVsID0gZW1wbG95ZWVNb2RlbCBhcyBqZXN0Lk1vY2tlZDx0eXBlb2YgZW1wbG95ZWVNb2RlbD47XG5cbmRlc2NyaWJlKCdMZWF2ZVNlcnZpY2UnLCAoKSA9PiB7XG4gIGxldCBsZWF2ZVNlcnZpY2U6IExlYXZlU2VydmljZTtcblxuICAvLyBTaGFyZWQgbW9jayBkYXRhXG4gIGNvbnN0IHZhbGlkTGVhdmVEYXRhOiBDcmVhdGVMZWF2ZVJlcXVlc3REYXRhID0ge1xuICAgIGVtcGxveWVlSWQ6ICdlbXAtMTIzJyxcbiAgICBsZWF2ZVR5cGU6ICd2YWNhdGlvbicsXG4gICAgc3RhcnREYXRlOiBuZXcgRGF0ZSgnMjAyNS0xMi0xNScpLFxuICAgIGVuZERhdGU6IG5ldyBEYXRlKCcyMDI1LTEyLTE3JyksXG4gICAgcmVhc29uOiAnRmFtaWx5IHZhY2F0aW9uJ1xuICB9O1xuXG4gIGNvbnN0IG1vY2tFbXBsb3llZSA9IHtcbiAgICBpZDogJ2VtcC0xMjMnLFxuICAgIHVzZXJfaWQ6ICd1c2VyLTEyMycsXG4gICAgZW1wbG95ZWVfaWQ6ICdFTVAwMDEnLFxuICAgIHBvc2l0aW9uOiAnU29mdHdhcmUgRGV2ZWxvcGVyJyxcbiAgICBkZXBhcnRtZW50X2lkOiAnZGVwdC0xMjMnLFxuICAgIGVtcGxveW1lbnRfdHlwZTogJ3JlZ3VsYXInIGFzIGNvbnN0LFxuICAgIGhpcmVfZGF0ZTogbmV3IERhdGUoJzIwMjMtMDEtMDEnKSxcbiAgICBiYXNlX3NhbGFyeTogNTAwMDAsXG4gICAgc3RhdHVzOiAnYWN0aXZlJyBhcyBjb25zdCxcbiAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLFxuICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKClcbiAgfTtcblxuICBjb25zdCBtb2NrTGVhdmU6IExlYXZlID0ge1xuICAgIGlkOiAnbGVhdmUtMTIzJyxcbiAgICBlbXBsb3llZUlkOiAnZW1wLTEyMycsXG4gICAgbGVhdmVUeXBlOiAndmFjYXRpb24nLFxuICAgIHN0YXJ0RGF0ZTogbmV3IERhdGUoJzIwMjUtMTItMTUnKSxcbiAgICBlbmREYXRlOiBuZXcgRGF0ZSgnMjAyNS0xMi0xNycpLFxuICAgIHRvdGFsRGF5czogMyxcbiAgICByZWFzb246ICdGYW1pbHkgdmFjYXRpb24nLFxuICAgIHN0YXR1czogJ3BlbmRpbmcnLFxuICAgIGFwcHJvdmVkQnk6IG51bGwsXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKVxuICB9O1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGxlYXZlU2VydmljZSA9IG5ldyBMZWF2ZVNlcnZpY2UoKTtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2NyZWF0ZUxlYXZlUmVxdWVzdCcsICgpID0+IHtcblxuICAgIGl0KCdzaG91bGQgY3JlYXRlIGEgbGVhdmUgcmVxdWVzdCBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBtb2NrRW1wbG95ZWVNb2RlbC5maW5kQnlJZC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrRW1wbG95ZWUpO1xuICAgICAgbW9ja0xlYXZlTW9kZWwuY3JlYXRlTGVhdmUubW9ja1Jlc29sdmVkVmFsdWUobW9ja0xlYXZlKTtcbiAgICAgIFxuICAgICAgLy8gTW9jayB0aGUgc3BlY2lmaWMgbWV0aG9kIGNhbGxlZCBieSBjcmVhdGVMZWF2ZVJlcXVlc3RcbiAgICAgIG1vY2tMZWF2ZUJhbGFuY2VNb2RlbC5maW5kQnlFbXBsb3llZUxlYXZlVHlwZUFuZFllYXIubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBpZDogJ2xiLTEnLFxuICAgICAgICBlbXBsb3llZUlkOiAnZW1wLTEyMycsXG4gICAgICAgIGxlYXZlVHlwZTogJ3ZhY2F0aW9uJyxcbiAgICAgICAgYmFsYW5jZTogMTUsXG4gICAgICAgIHllYXI6IDIwMjUsXG4gICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIE1vY2sgY2hlY2tPdmVybGFwcGluZ0xlYXZlcyB0byByZXR1cm4gbm8gb3ZlcmxhcHNcbiAgICAgIG1vY2tMZWF2ZU1vZGVsLmNoZWNrT3ZlcmxhcHBpbmdMZWF2ZXMubW9ja1Jlc29sdmVkVmFsdWUoW10pO1xuICAgICAgXG4gICAgICBtb2NrTGVhdmVNb2RlbC5saXN0TGVhdmVzLm1vY2tSZXNvbHZlZFZhbHVlKHsgbGVhdmVzOiBbXSwgdG90YWw6IDAsIHBhZ2U6IDEsIGxpbWl0OiAxMCwgdG90YWxQYWdlczogMSB9KTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsZWF2ZVNlcnZpY2UuY3JlYXRlTGVhdmVSZXF1ZXN0KHZhbGlkTGVhdmVEYXRhKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QobW9ja0VtcGxveWVlTW9kZWwuZmluZEJ5SWQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdlbXAtMTIzJyk7XG4gICAgICBleHBlY3QobW9ja0xlYXZlTW9kZWwuY3JlYXRlTGVhdmUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgZW1wbG95ZWVJZDogJ2VtcC0xMjMnLFxuICAgICAgICBsZWF2ZVR5cGU6ICd2YWNhdGlvbicsXG4gICAgICAgIHN0YXJ0RGF0ZTogbmV3IERhdGUoJzIwMjUtMTItMTUnKSxcbiAgICAgICAgZW5kRGF0ZTogbmV3IERhdGUoJzIwMjUtMTItMTcnKSxcbiAgICAgICAgcmVhc29uOiAnRmFtaWx5IHZhY2F0aW9uJyxcbiAgICAgICAgdG90YWxEYXlzOiAzXG4gICAgICB9KTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwobW9ja0xlYXZlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgZXJyb3IgaWYgZW1wbG95ZWUgbm90IGZvdW5kJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgbW9ja0VtcGxveWVlTW9kZWwuZmluZEJ5SWQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG5cbiAgICAgIC8vIEFjdCAmIEFzc2VydFxuICAgICAgYXdhaXQgZXhwZWN0KGxlYXZlU2VydmljZS5jcmVhdGVMZWF2ZVJlcXVlc3QodmFsaWRMZWF2ZURhdGEpKVxuICAgICAgICAucmVqZWN0cy50b1Rocm93KCdFbXBsb3llZSBub3QgZm91bmQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgZXJyb3IgaWYgZW1wbG95ZWUgaXMgbm90IGFjdGl2ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IGluYWN0aXZlRW1wbG95ZWUgPSB7IC4uLm1vY2tFbXBsb3llZSwgc3RhdHVzOiAnaW5hY3RpdmUnIGFzIGNvbnN0IH07XG4gICAgICBtb2NrRW1wbG95ZWVNb2RlbC5maW5kQnlJZC5tb2NrUmVzb2x2ZWRWYWx1ZShpbmFjdGl2ZUVtcGxveWVlKTtcblxuICAgICAgLy8gQWN0ICYgQXNzZXJ0XG4gICAgICBhd2FpdCBleHBlY3QobGVhdmVTZXJ2aWNlLmNyZWF0ZUxlYXZlUmVxdWVzdCh2YWxpZExlYXZlRGF0YSkpXG4gICAgICAgIC5yZWplY3RzLnRvVGhyb3coJ0VtcGxveWVlIGlzIG5vdCBhY3RpdmUnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgZXJyb3IgaWYgZW5kIGRhdGUgaXMgYmVmb3JlIHN0YXJ0IGRhdGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBpbnZhbGlkRGF0YSA9IHtcbiAgICAgICAgLi4udmFsaWRMZWF2ZURhdGEsXG4gICAgICAgIHN0YXJ0RGF0ZTogbmV3IERhdGUoJzIwMjUtMTItMTcnKSxcbiAgICAgICAgZW5kRGF0ZTogbmV3IERhdGUoJzIwMjUtMTItMTUnKVxuICAgICAgfTtcbiAgICAgIG1vY2tFbXBsb3llZU1vZGVsLmZpbmRCeUlkLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tFbXBsb3llZSk7XG5cbiAgICAgIC8vIEFjdCAmIEFzc2VydFxuICAgICAgYXdhaXQgZXhwZWN0KGxlYXZlU2VydmljZS5jcmVhdGVMZWF2ZVJlcXVlc3QoaW52YWxpZERhdGEpKVxuICAgICAgICAucmVqZWN0cy50b1Rocm93KCdTdGFydCBkYXRlIG11c3QgYmUgYmVmb3JlIGVuZCBkYXRlJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHRocm93IGVycm9yIGlmIGxlYXZlIHJlcXVlc3QgaXMgZm9yIHBhc3QgZGF0ZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBwYXN0RGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICBwYXN0RGF0ZS5zZXREYXRlKHBhc3REYXRlLmdldERhdGUoKSAtIDEpO1xuICAgICAgY29uc3QgcGFzdEVuZERhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgcGFzdEVuZERhdGUuc2V0RGF0ZShwYXN0RW5kRGF0ZS5nZXREYXRlKCkgLSAxKTtcbiAgICAgIHBhc3RFbmREYXRlLnNldERhdGUocGFzdEVuZERhdGUuZ2V0RGF0ZSgpICsgMik7IC8vIE1ha2UgZW5kIGRhdGUgYWZ0ZXIgc3RhcnQgZGF0ZVxuICAgICAgY29uc3QgaW52YWxpZERhdGEgPSB7XG4gICAgICAgIC4uLnZhbGlkTGVhdmVEYXRhLFxuICAgICAgICBzdGFydERhdGU6IHBhc3REYXRlLFxuICAgICAgICBlbmREYXRlOiBwYXN0RW5kRGF0ZVxuICAgICAgfTtcbiAgICAgIG1vY2tFbXBsb3llZU1vZGVsLmZpbmRCeUlkLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tFbXBsb3llZSk7XG5cbiAgICAgIC8vIEFjdCAmIEFzc2VydFxuICAgICAgYXdhaXQgZXhwZWN0KGxlYXZlU2VydmljZS5jcmVhdGVMZWF2ZVJlcXVlc3QoaW52YWxpZERhdGEpKVxuICAgICAgICAucmVqZWN0cy50b1Rocm93KCdDYW5ub3QgcmVxdWVzdCBsZWF2ZSBmb3IgcGFzdCBkYXRlcycpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0TGVhdmVSZXF1ZXN0JywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tMZWF2ZVdpdGhEZXRhaWxzOiBMZWF2ZVdpdGhEZXRhaWxzID0ge1xuICAgICAgaWQ6ICdsZWF2ZS0xMjMnLFxuICAgICAgZW1wbG95ZWVJZDogJ2VtcC0xMjMnLFxuICAgICAgbGVhdmVUeXBlOiAndmFjYXRpb24nLFxuICAgICAgc3RhcnREYXRlOiBuZXcgRGF0ZSgnMjAyNS0xMi0xNScpLFxuICAgICAgZW5kRGF0ZTogbmV3IERhdGUoJzIwMjUtMTItMTcnKSxcbiAgICAgIHRvdGFsRGF5czogMyxcbiAgICAgIHJlYXNvbjogJ0ZhbWlseSB2YWNhdGlvbicsXG4gICAgICBzdGF0dXM6ICdwZW5kaW5nJyxcbiAgICAgIGFwcHJvdmVkQnk6IG51bGwsXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICBlbXBsb3llZUNvZGU6ICdFTVAwMDEnLFxuICAgICAgZW1wbG95ZWVOYW1lOiAnSm9obiBEb2UnLFxuICAgICAgZGVwYXJ0bWVudE5hbWU6ICdFbmdpbmVlcmluZycsXG4gICAgICBhcHByb3Zlck5hbWU6IG51bGxcbiAgICB9O1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gbGVhdmUgcmVxdWVzdCB3aXRoIGRldGFpbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBtb2NrTGVhdmVNb2RlbC5maW5kQnlJZFdpdGhEZXRhaWxzLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tMZWF2ZVdpdGhEZXRhaWxzKTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsZWF2ZVNlcnZpY2UuZ2V0TGVhdmVSZXF1ZXN0KCdsZWF2ZS0xMjMnKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QobW9ja0xlYXZlTW9kZWwuZmluZEJ5SWRXaXRoRGV0YWlscykudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2xlYXZlLTEyMycpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrTGVhdmVXaXRoRGV0YWlscyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBudWxsIGlmIGxlYXZlIHJlcXVlc3Qgbm90IGZvdW5kJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgbW9ja0xlYXZlTW9kZWwuZmluZEJ5SWRXaXRoRGV0YWlscy5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsZWF2ZVNlcnZpY2UuZ2V0TGVhdmVSZXF1ZXN0KCdub25leGlzdGVudCcpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdhcHByb3ZlTGVhdmVSZXF1ZXN0JywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tMZWF2ZTogTGVhdmUgPSB7XG4gICAgICBpZDogJ2xlYXZlLTEyMycsXG4gICAgICBlbXBsb3llZUlkOiAnZW1wLTEyMycsXG4gICAgICBsZWF2ZVR5cGU6ICd2YWNhdGlvbicsXG4gICAgICBzdGFydERhdGU6IG5ldyBEYXRlKCcyMDI1LTEyLTE1JyksXG4gICAgICBlbmREYXRlOiBuZXcgRGF0ZSgnMjAyNS0xMi0xNycpLFxuICAgICAgdG90YWxEYXlzOiAzLFxuICAgICAgcmVhc29uOiAnRmFtaWx5IHZhY2F0aW9uJyxcbiAgICAgIHN0YXR1czogJ3BlbmRpbmcnLFxuICAgICAgYXBwcm92ZWRCeTogbnVsbCxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKVxuICAgIH07XG5cbiAgICBjb25zdCBhcHByb3ZlRGF0YTogQXBwcm92ZUxlYXZlRGF0YSA9IHtcbiAgICAgIGxlYXZlSWQ6ICdsZWF2ZS0xMjMnLFxuICAgICAgYXBwcm92ZXJJZDogJ2FwcHJvdmVyLTEyMycsXG4gICAgICBhcHByb3ZlZDogdHJ1ZSxcbiAgICAgIGNvbW1lbnRzOiAnQXBwcm92ZWQgZm9yIGZhbWlseSB2YWNhdGlvbidcbiAgICB9O1xuXG4gICAgaXQoJ3Nob3VsZCBhcHByb3ZlIGxlYXZlIHJlcXVlc3Qgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgbW9ja0xlYXZlTW9kZWwuZmluZEJ5SWQubW9ja1Jlc29sdmVkVmFsdWUobW9ja0xlYXZlKTtcbiAgICAgIG1vY2tMZWF2ZU1vZGVsLnVwZGF0ZUxlYXZlLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgLi4ubW9ja0xlYXZlLFxuICAgICAgICBzdGF0dXM6ICdhcHByb3ZlZCcgYXMgY29uc3QsXG4gICAgICAgIGFwcHJvdmVkQnk6ICdhcHByb3Zlci0xMjMnLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIE1vY2sgdGhlIHNwZWNpZmljIG1ldGhvZCBjYWxsZWQgYnkgYXBwcm92ZUxlYXZlUmVxdWVzdFxuICAgICAgbW9ja0xlYXZlQmFsYW5jZU1vZGVsLnVzZUxlYXZlRGF5cy5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGlkOiAnbGItMScsXG4gICAgICAgIGVtcGxveWVlSWQ6ICdlbXAtMTIzJyxcbiAgICAgICAgbGVhdmVUeXBlOiAndmFjYXRpb24nLFxuICAgICAgICBiYWxhbmNlOiAxMiwgLy8gMTUgLSAzIGRheXNcbiAgICAgICAgeWVhcjogMjAyNSxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpXG4gICAgICB9KTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsZWF2ZVNlcnZpY2UuYXBwcm92ZUxlYXZlUmVxdWVzdChhcHByb3ZlRGF0YSk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KG1vY2tMZWF2ZU1vZGVsLmZpbmRCeUlkKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnbGVhdmUtMTIzJyk7XG4gICAgICBleHBlY3QobW9ja0xlYXZlTW9kZWwudXBkYXRlTGVhdmUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdsZWF2ZS0xMjMnLCB7XG4gICAgICAgIHN0YXR1czogJ2FwcHJvdmVkJyBhcyBjb25zdCxcbiAgICAgICAgYXBwcm92ZWRCeTogJ2FwcHJvdmVyLTEyMycsXG4gICAgICB9KTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc3RhdHVzKS50b0JlKCdhcHByb3ZlZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3QgbGVhdmUgcmVxdWVzdCBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCByZWplY3REYXRhID0geyAuLi5hcHByb3ZlRGF0YSwgYXBwcm92ZWQ6IGZhbHNlIH07XG4gICAgICBtb2NrTGVhdmVNb2RlbC5maW5kQnlJZC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrTGVhdmUpO1xuICAgICAgbW9ja0xlYXZlTW9kZWwudXBkYXRlTGVhdmUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAuLi5tb2NrTGVhdmUsXG4gICAgICAgIHN0YXR1czogJ3JlamVjdGVkJyBhcyBjb25zdCxcbiAgICAgICAgYXBwcm92ZWRCeTogJ2FwcHJvdmVyLTEyMycsXG4gICAgICB9KTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsZWF2ZVNlcnZpY2UuYXBwcm92ZUxlYXZlUmVxdWVzdChyZWplY3REYXRhKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QocmVzdWx0LnN0YXR1cykudG9CZSgncmVqZWN0ZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgZXJyb3IgaWYgbGVhdmUgcmVxdWVzdCBub3QgZm91bmQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBtb2NrTGVhdmVNb2RlbC5maW5kQnlJZC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcblxuICAgICAgLy8gQWN0ICYgQXNzZXJ0XG4gICAgICBhd2FpdCBleHBlY3QobGVhdmVTZXJ2aWNlLmFwcHJvdmVMZWF2ZVJlcXVlc3QoYXBwcm92ZURhdGEpKVxuICAgICAgICAucmVqZWN0cy50b1Rocm93KCdMZWF2ZSByZXF1ZXN0IG5vdCBmb3VuZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBlcnJvciBpZiBsZWF2ZSByZXF1ZXN0IGlzIGFscmVhZHkgcHJvY2Vzc2VkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgcHJvY2Vzc2VkTGVhdmUgPSB7IC4uLm1vY2tMZWF2ZSwgc3RhdHVzOiAnYXBwcm92ZWQnIGFzIGNvbnN0IH07XG4gICAgICBtb2NrTGVhdmVNb2RlbC5maW5kQnlJZC5tb2NrUmVzb2x2ZWRWYWx1ZShwcm9jZXNzZWRMZWF2ZSk7XG5cbiAgICAgIC8vIEFjdCAmIEFzc2VydFxuICAgICAgYXdhaXQgZXhwZWN0KGxlYXZlU2VydmljZS5hcHByb3ZlTGVhdmVSZXF1ZXN0KGFwcHJvdmVEYXRhKSlcbiAgICAgICAgLnJlamVjdHMudG9UaHJvdygnUmVxdWVzdCBoYXMgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0RW1wbG95ZWVMZWF2ZUJhbGFuY2UnLCAoKSA9PiB7XG4gICAgY29uc3QgbW9ja0xlYXZlQmFsYW5jZXM6IExlYXZlQmFsYW5jZVdpdGhEZXRhaWxzW10gPSBbXG4gICAgICB7XG4gICAgICAgIGlkOiAnbGItMScsXG4gICAgICAgIGVtcGxveWVlSWQ6ICdlbXAtMTIzJyxcbiAgICAgICAgbGVhdmVUeXBlOiAndmFjYXRpb24nLFxuICAgICAgICBiYWxhbmNlOiAxNSxcbiAgICAgICAgeWVhcjogMjAyNSxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICBlbXBsb3llZUNvZGU6ICdFTVAwMDEnLFxuICAgICAgICBlbXBsb3llZU5hbWU6ICdKb2huIERvZScsXG4gICAgICAgIGRlcGFydG1lbnROYW1lOiAnRW5naW5lZXJpbmcnXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogJ2xiLTInLFxuICAgICAgICBlbXBsb3llZUlkOiAnZW1wLTEyMycsXG4gICAgICAgIGxlYXZlVHlwZTogJ3NpY2snLFxuICAgICAgICBiYWxhbmNlOiAxMCxcbiAgICAgICAgeWVhcjogMjAyNSxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICBlbXBsb3llZUNvZGU6ICdFTVAwMDEnLFxuICAgICAgICBlbXBsb3llZU5hbWU6ICdKb2huIERvZScsXG4gICAgICAgIGRlcGFydG1lbnROYW1lOiAnRW5naW5lZXJpbmcnXG4gICAgICB9XG4gICAgXTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGxlYXZlIGJhbGFuY2Ugc3VtbWFyeSBmb3IgZW1wbG95ZWUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBtb2NrTGVhdmVCYWxhbmNlTW9kZWwuZ2V0RW1wbG95ZWVMZWF2ZUJhbGFuY2VzLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tMZWF2ZUJhbGFuY2VzKTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsZWF2ZVNlcnZpY2UuZ2V0RW1wbG95ZWVMZWF2ZUJhbGFuY2UoJ2VtcC0xMjMnLCAyMDI1KTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QobW9ja0xlYXZlQmFsYW5jZU1vZGVsLmdldEVtcGxveWVlTGVhdmVCYWxhbmNlcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2VtcC0xMjMnLCAyMDI1KTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoe1xuICAgICAgICB2YWNhdGlvbjogeyB0b3RhbDogMTUsIHVzZWQ6IDAsIGF2YWlsYWJsZTogMTUgfSxcbiAgICAgICAgc2ljazogeyB0b3RhbDogMTAsIHVzZWQ6IDAsIGF2YWlsYWJsZTogMTAgfSxcbiAgICAgICAgbWF0ZXJuaXR5OiB7IHRvdGFsOiAwLCB1c2VkOiAwLCBhdmFpbGFibGU6IDAgfSxcbiAgICAgICAgb3RoZXI6IHsgdG90YWw6IDAsIHVzZWQ6IDAsIGF2YWlsYWJsZTogMCB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdXNlIGN1cnJlbnQgeWVhciBpZiB5ZWFyIG5vdCBwcm92aWRlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IGN1cnJlbnRZZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuICAgICAgbW9ja0xlYXZlQmFsYW5jZU1vZGVsLmdldEVtcGxveWVlTGVhdmVCYWxhbmNlcy5tb2NrUmVzb2x2ZWRWYWx1ZShbXSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgYXdhaXQgbGVhdmVTZXJ2aWNlLmdldEVtcGxveWVlTGVhdmVCYWxhbmNlKCdlbXAtMTIzJyk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KG1vY2tMZWF2ZUJhbGFuY2VNb2RlbC5nZXRFbXBsb3llZUxlYXZlQmFsYW5jZXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdlbXAtMTIzJywgY3VycmVudFllYXIpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gemVybyBiYWxhbmNlcyBpZiBubyBsZWF2ZSBiYWxhbmNlcyBmb3VuZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIG1vY2tMZWF2ZUJhbGFuY2VNb2RlbC5nZXRFbXBsb3llZUxlYXZlQmFsYW5jZXMubW9ja1Jlc29sdmVkVmFsdWUoW10pO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxlYXZlU2VydmljZS5nZXRFbXBsb3llZUxlYXZlQmFsYW5jZSgnZW1wLTEyMycsIDIwMjQpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoe1xuICAgICAgICB2YWNhdGlvbjogeyB0b3RhbDogMCwgdXNlZDogMCwgYXZhaWxhYmxlOiAwIH0sXG4gICAgICAgIHNpY2s6IHsgdG90YWw6IDAsIHVzZWQ6IDAsIGF2YWlsYWJsZTogMCB9LFxuICAgICAgICBtYXRlcm5pdHk6IHsgdG90YWw6IDAsIHVzZWQ6IDAsIGF2YWlsYWJsZTogMCB9LFxuICAgICAgICBvdGhlcjogeyB0b3RhbDogMCwgdXNlZDogMCwgYXZhaWxhYmxlOiAwIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgndmFsaWRhdGVMZWF2ZVJlcXVlc3QnLCAoKSA9PiB7XG4gICAgY29uc3QgdmFsaWRMZWF2ZURhdGE6IENyZWF0ZUxlYXZlUmVxdWVzdERhdGEgPSB7XG4gICAgICBlbXBsb3llZUlkOiAnZW1wLTEyMycsXG4gICAgICBsZWF2ZVR5cGU6ICd2YWNhdGlvbicsXG4gICAgICBzdGFydERhdGU6IG5ldyBEYXRlKCcyMDI1LTEyLTE1JyksXG4gICAgICBlbmREYXRlOiBuZXcgRGF0ZSgnMjAyNS0xMi0xNycpLFxuICAgICAgcmVhc29uOiAnRmFtaWx5IHZhY2F0aW9uJ1xuICAgIH07XG5cbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIGxlYXZlIHJlcXVlc3Qgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgLy8gTW9jayB0aGUgc3BlY2lmaWMgbWV0aG9kIGNhbGxlZCBieSB2YWxpZGF0ZUxlYXZlUmVxdWVzdFxuICAgICAgbW9ja0xlYXZlQmFsYW5jZU1vZGVsLmZpbmRCeUVtcGxveWVlTGVhdmVUeXBlQW5kWWVhci5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGlkOiAnbGItMScsXG4gICAgICAgIGVtcGxveWVlSWQ6ICdlbXAtMTIzJyxcbiAgICAgICAgbGVhdmVUeXBlOiAndmFjYXRpb24nLFxuICAgICAgICBiYWxhbmNlOiAxNSxcbiAgICAgICAgeWVhcjogMjAyNSxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgbW9ja0xlYXZlTW9kZWwuY2hlY2tPdmVybGFwcGluZ0xlYXZlcy5tb2NrUmVzb2x2ZWRWYWx1ZShbXSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbGVhdmVTZXJ2aWNlLnZhbGlkYXRlTGVhdmVSZXF1ZXN0KHZhbGlkTGVhdmVEYXRhKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QocmVzdWx0LmlzVmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9ycykudG9IYXZlTGVuZ3RoKDApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gdmFsaWRhdGlvbiBlcnJvcnMgZm9yIGluc3VmZmljaWVudCBsZWF2ZSBiYWxhbmNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgaW5zdWZmaWNpZW50QmFsYW5jZURhdGEgPSB7XG4gICAgICAgIC4uLnZhbGlkTGVhdmVEYXRhLFxuICAgICAgICBzdGFydERhdGU6IG5ldyBEYXRlKCcyMDI1LTEyLTE1JyksXG4gICAgICAgIGVuZERhdGU6IG5ldyBEYXRlKCcyMDI1LTEyLTMxJykgLy8gMTYgZGF5c1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gTW9jayBlbXBsb3llZSBsb29rdXBcbiAgICAgIG1vY2tFbXBsb3llZU1vZGVsLmZpbmRCeUlkLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tFbXBsb3llZSk7XG4gICAgICBcbiAgICAgIC8vIE1vY2sgdGhlIHNwZWNpZmljIG1ldGhvZCBjYWxsZWQgYnkgdmFsaWRhdGVMZWF2ZVJlcXVlc3RcbiAgICAgIG1vY2tMZWF2ZUJhbGFuY2VNb2RlbC5maW5kQnlFbXBsb3llZUxlYXZlVHlwZUFuZFllYXIubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBpZDogJ2xiLTEnLFxuICAgICAgICBlbXBsb3llZUlkOiAnZW1wLTEyMycsXG4gICAgICAgIGxlYXZlVHlwZTogJ3ZhY2F0aW9uJyxcbiAgICAgICAgYmFsYW5jZTogMTUsIC8vIExlc3MgdGhhbiB0aGUgMTYgZGF5cyByZXF1ZXN0ZWRcbiAgICAgICAgeWVhcjogMjAyNSxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gTW9jayBjaGVja092ZXJsYXBwaW5nTGVhdmVzIHRvIHJldHVybiBubyBvdmVybGFwc1xuICAgICAgbW9ja0xlYXZlTW9kZWwuY2hlY2tPdmVybGFwcGluZ0xlYXZlcy5tb2NrUmVzb2x2ZWRWYWx1ZShbXSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbGVhdmVTZXJ2aWNlLnZhbGlkYXRlTGVhdmVSZXF1ZXN0KGluc3VmZmljaWVudEJhbGFuY2VEYXRhKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QocmVzdWx0LmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcnMpLnRvQ29udGFpbignSW5zdWZmaWNpZW50IGxlYXZlIGJhbGFuY2UuIEF2YWlsYWJsZTogMTUgZGF5cywgUmVxdWVzdGVkOiAxNiBkYXlzJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiB2YWxpZGF0aW9uIGVycm9ycyBmb3Igb3ZlcmxhcHBpbmcgcmVxdWVzdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBtb2NrT3ZlcmxhcHBpbmdSZXF1ZXN0czogTGVhdmVbXSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAnbGVhdmUtNDU2JyxcbiAgICAgICAgICBlbXBsb3llZUlkOiAnZW1wLTEyMycsXG4gICAgICAgICAgbGVhdmVUeXBlOiAnc2ljaycsXG4gICAgICAgICAgc3RhcnREYXRlOiBuZXcgRGF0ZSgnMjAyNC0wMS0xNicpLFxuICAgICAgICAgIGVuZERhdGU6IG5ldyBEYXRlKCcyMDI0LTAxLTE4JyksXG4gICAgICAgICAgdG90YWxEYXlzOiAzLFxuICAgICAgICAgIHJlYXNvbjogbnVsbCxcbiAgICAgICAgICBzdGF0dXM6ICdwZW5kaW5nJyBhcyBjb25zdCxcbiAgICAgICAgICBhcHByb3ZlZEJ5OiBudWxsLFxuICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKClcbiAgICAgICAgfVxuICAgICAgXTtcbiAgICAgIG1vY2tMZWF2ZUJhbGFuY2VNb2RlbC5nZXRFbXBsb3llZUxlYXZlQmFsYW5jZXMubW9ja1Jlc29sdmVkVmFsdWUoW10pO1xuICAgICAgbW9ja0xlYXZlTW9kZWwuY2hlY2tPdmVybGFwcGluZ0xlYXZlcy5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrT3ZlcmxhcHBpbmdSZXF1ZXN0cyk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbGVhdmVTZXJ2aWNlLnZhbGlkYXRlTGVhdmVSZXF1ZXN0KHZhbGlkTGVhdmVEYXRhKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QocmVzdWx0LmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcnMpLnRvQ29udGFpbignTGVhdmUgcmVxdWVzdCBvdmVybGFwcyB3aXRoIGV4aXN0aW5nIGFwcHJvdmVkIGxlYXZlJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdnZXRFbXBsb3llZUxlYXZlUmVxdWVzdHMnLCAoKSA9PiB7XG4gICAgY29uc3QgbW9ja0xlYXZlUmVxdWVzdHM6IExlYXZlV2l0aERldGFpbHNbXSA9IFtcbiAgICAgIHtcbiAgICAgICAgaWQ6ICdsZWF2ZS0xMjMnLFxuICAgICAgICBlbXBsb3llZUlkOiAnZW1wLTEyMycsXG4gICAgICAgIGxlYXZlVHlwZTogJ3ZhY2F0aW9uJyxcbiAgICAgICAgc3RhcnREYXRlOiBuZXcgRGF0ZSgnMjAyNS0xMi0xNScpLFxuICAgICAgICBlbmREYXRlOiBuZXcgRGF0ZSgnMjAyNS0xMi0xNycpLFxuICAgICAgICB0b3RhbERheXM6IDMsXG4gICAgICAgIHJlYXNvbjogJ0ZhbWlseSB2YWNhdGlvbicsXG4gICAgICAgIHN0YXR1czogJ2FwcHJvdmVkJyBhcyBjb25zdCxcbiAgICAgICAgYXBwcm92ZWRCeTogJ2FwcHJvdmVyLTEyMycsXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICBlbXBsb3llZUNvZGU6ICdFTVAwMDEnLFxuICAgICAgICBlbXBsb3llZU5hbWU6ICdKb2huIERvZScsXG4gICAgICAgIGRlcGFydG1lbnROYW1lOiAnRW5naW5lZXJpbmcnLFxuICAgICAgICBhcHByb3Zlck5hbWU6ICdKYW5lIFNtaXRoJ1xuICAgICAgfVxuICAgIF07XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBlbXBsb3llZSBsZWF2ZSByZXF1ZXN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIG1vY2tMZWF2ZU1vZGVsLmxpc3RMZWF2ZXMubW9ja1Jlc29sdmVkVmFsdWUoeyBsZWF2ZXM6IG1vY2tMZWF2ZVJlcXVlc3RzLCB0b3RhbDogMSwgcGFnZTogMSwgbGltaXQ6IDEwLCB0b3RhbFBhZ2VzOiAxIH0pO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxlYXZlU2VydmljZS5nZXRFbXBsb3llZUxlYXZlUmVxdWVzdHMoJ2VtcC0xMjMnKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QobW9ja0xlYXZlTW9kZWwubGlzdExlYXZlcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICBlbXBsb3llZUlkOiAnZW1wLTEyMycsXG4gICAgICAgIHN0YXJ0RGF0ZTogdW5kZWZpbmVkLFxuICAgICAgICBlbmREYXRlOiB1bmRlZmluZWQsXG4gICAgICAgIHBhZ2U6IDEsXG4gICAgICAgIGxpbWl0OiAyMCxcbiAgICAgICAgc29ydEJ5OiAnY3JlYXRlZF9hdCcsXG4gICAgICAgIHNvcnRPcmRlcjogJ2Rlc2MnXG4gICAgICB9KTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoe1xuICAgICAgICBsZWF2ZXM6IG1vY2tMZWF2ZVJlcXVlc3RzLFxuICAgICAgICB0b3RhbDogMSxcbiAgICAgICAgcGFnZTogMSxcbiAgICAgICAgbGltaXQ6IDEwLFxuICAgICAgICB0b3RhbFBhZ2VzOiAxXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdXNlIGN1cnJlbnQgeWVhciBpZiB5ZWFyIG5vdCBwcm92aWRlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIG1vY2tMZWF2ZU1vZGVsLmxpc3RMZWF2ZXMubW9ja1Jlc29sdmVkVmFsdWUoeyBsZWF2ZXM6IFtdLCB0b3RhbDogMCwgcGFnZTogMSwgbGltaXQ6IDEwLCB0b3RhbFBhZ2VzOiAxIH0pO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGF3YWl0IGxlYXZlU2VydmljZS5nZXRFbXBsb3llZUxlYXZlUmVxdWVzdHMoJ2VtcC0xMjMnKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QobW9ja0xlYXZlTW9kZWwubGlzdExlYXZlcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICBlbXBsb3llZUlkOiAnZW1wLTEyMycsXG4gICAgICAgIHN0YXJ0RGF0ZTogdW5kZWZpbmVkLFxuICAgICAgICBlbmREYXRlOiB1bmRlZmluZWQsXG4gICAgICAgIHBhZ2U6IDEsXG4gICAgICAgIGxpbWl0OiAyMCxcbiAgICAgICAgc29ydEJ5OiAnY3JlYXRlZF9hdCcsXG4gICAgICAgIHNvcnRPcmRlcjogJ2Rlc2MnXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2RlbGV0ZUxlYXZlUmVxdWVzdCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGRlbGV0ZSBsZWF2ZSByZXF1ZXN0IHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIG1vY2tMZWF2ZU1vZGVsLmZpbmRCeUlkLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tMZWF2ZSk7XG4gICAgICBtb2NrTGVhdmVNb2RlbC5kZWxldGVMZWF2ZS5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsZWF2ZVNlcnZpY2UuZGVsZXRlTGVhdmVSZXF1ZXN0KCdsZWF2ZS0xMjMnKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QobW9ja0xlYXZlTW9kZWwuZmluZEJ5SWQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdsZWF2ZS0xMjMnKTtcbiAgICAgIGV4cGVjdChtb2NrTGVhdmVNb2RlbC5kZWxldGVMZWF2ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2xlYXZlLTEyMycpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgZXJyb3IgaWYgbGVhdmUgcmVxdWVzdCBub3QgZm91bmQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBtb2NrTGVhdmVNb2RlbC5maW5kQnlJZC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcblxuICAgICAgLy8gQWN0ICYgQXNzZXJ0XG4gICAgICBhd2FpdCBleHBlY3QobGVhdmVTZXJ2aWNlLmRlbGV0ZUxlYXZlUmVxdWVzdCgnbm9uZXhpc3RlbnQnKSlcbiAgICAgICAgLnJlamVjdHMudG9UaHJvdygnTGVhdmUgcmVxdWVzdCBub3QgZm91bmQnKTtcbiAgICAgIGV4cGVjdChtb2NrTGVhdmVNb2RlbC5maW5kQnlJZCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ25vbmV4aXN0ZW50Jyk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwidmVyc2lvbiI6M30=